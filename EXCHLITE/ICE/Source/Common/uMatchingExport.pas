unit uMatchingExport;

interface

uses
  Classes, SysUtils, ComObj, Controls, Variants, Forms,
  // Exchequer units
  Enterprise01_Tlb,
  // ICE units
  MSXML2_TLB,
  uXmlBaseClass,
  uConsts,
  uCommon,
  uExportBaseClass,
  uXMLFileManager,
  uXMLWriter
  ;

{$I ice.inc}

type
  TMatchingExport = class(_ExportBase)
  private
    fFromDate: TDateTime;
    fToDate: TDateTime;
    oToolkit: IToolkit;
    fOutputDirectory: string;
    FileManager: TXMLFileManager;
    XMLWriter: TXMLWriter;
    fRecordsPerFile: Integer;
    function BuildRecord: Boolean;
    procedure SetOutputDirectory(const Value: string);
  public
    constructor Create;
    destructor Destroy; override;
    function LoadFromDB: Boolean; override;
    property FromDate: TDateTime read fFromDate write fFromDate;
    property RecordsPerFile: Integer read fRecordsPerFile write fRecordsPerFile;
    property ToDate: TDateTime read fToDate write fToDate;
    property OutputDirectory: string
      read fOutputDirectory write SetOutputDirectory;
  end;

implementation

uses
  CTKUtil,
  DateUtils
  ;

{ TMatchingExport }

constructor TMatchingExport.Create;
begin
  inherited Create;
  UseFiles := True;
  FileManager := TXMLFileManager.Create;
  RecordsPerFile := 1;
  FileManager.BaseFileName := 'mat';
  XMLWriter := TXMLWriter.Create;
  XMLWriter.NameSpace := 'match';
end;

destructor TMatchingExport.Destroy;
begin
  if Assigned(oToolkit) then
  begin
    oToolkit.CloseToolkit;
    oToolkit := nil;
  end;
  FileManager.Free;
  inherited;
end;

function TMatchingExport.LoadFromDB: Boolean;

var
  FuncRes: LongInt;
  Key: ShortString;
  ErrorCode: Integer;
  oTrans: ITransaction;
  StartYear, StartPeriod: Byte;
  EndYear, EndPeriod: Byte;
  FileName: string;

  function IsInRange(oTrans: ITransaction): Boolean;
  begin
    Result := (oTrans.thPeriod <= EndPeriod) and
              (oTrans.thYear   <= EndYear);
  end;

  function IsAutogenerated(oTrans: ITransaction): Boolean;
  var
    oMatching: IMatching;
    FuncRes: Integer;
  begin
    Result := False;
    if (oTrans.thDocType = dtNMT) then
    begin
      oMatching := oTrans.thMatching;
      FuncRes := oMatching.GetFirst;
      while (FuncRes = 0) do
      begin
        if (oMatching.maType in [maTypeFinancial, maTypeSPOP, maTypeCIS]) then
        begin
          Result := True;
          break;
        end;
        FuncRes := oMatching.GetNext;
      end;
    end;
  end;

  function IncludeRecord(oTrans: ITransaction): Boolean;
  var
    DocCode: string;
    oMatch: IMatching;
  const
    DocCodes: string =
//      'ADJ NOM SIN SRC SCR SJI SJC SRF SRI SQU SOR SBT PIN PPY PCR PJI PJC PRF PPI PQU POR PBT';
      'NOM SIN SJI SJC SRF SRC SCR SRI PIN PJI PJC PPI PRF PCR PPY SBT PBT';
  begin
    DocCode := Copy(oTrans.thOurRef, 1, 3);
    Result := (Pos(DocCode, DocCodes) <> 0);
    { Don't include auto-items. }
    if (oTrans.thRunNo = -1) or
       (oTrans.thRunNo = -2) then
      Result := False;
    if (Result) then
    begin
      oMatch := oTrans.thMatching;
      Result := (oMatch.GetFirst = 0) and (oMatch.maType = maTypeFinancial);
    end;
    if (Result) then
    begin
      Result := not IsAutogenerated(oTrans);
    end;
  end;

begin
  ErrorCode := 0;
  FileManager.Directory := DataPath + cICEFOLDER;

  { Remove any existing drip-feed files from the export path. }
  DeleteFiles(FileManager.Directory, FileManager.BaseFileName + '*.xml');
  
  oToolkit := OpenToolkit(DataPath, True);
  if not Assigned(oToolkit) then
  begin
    DoLogMessage('TMatchingExport.LoadFromDB: Cannot create COM Toolkit instance', cCONNECTINGDBERROR);
    Result := False;
    Exit;
  end;
  oTrans := oToolkit.Transaction;
  try
    oTrans.Index := thIdxYearPeriod;
    if not VarIsNull(Param1) then
    begin
      StartPeriod := Param1;
      StartYear   := Param2;
      EndPeriod   := Param3;
      EndYear     := Param4;
      { Find the first transaction in the specified period. }
      Key := oTrans.BuildYearPeriodIndex(StartYear, StartPeriod);
      FuncRes := oTrans.GetGreaterThanOrEqual(Key);
    end
    else
      FuncRes := oTrans.GetFirst;
    Result  := (FuncRes = 0);
    while (FuncRes = 0) and (IsInRange(oTrans)) do
    begin
      if IncludeRecord(oTrans) then
      begin
        { Start a new XML file. }
        XMLWriter.Start(cMATCHINGTABLE, 'match');
        { Build the required XML record from the Matching details. }
        BuildRecord;
        { Finish the XML file and save the filename. }
        XMLWriter.Finish;
        FileName := FileManager.SaveXML(XMLWriter.XML.Text);
        Files.Add(FileName);
      end; { if (IncludeRecord(oTrans)... }

      { Find the next transaction record }
      FuncRes := oTrans.GetNext;

      Application.ProcessMessages;
    end;
  finally
    oTrans := nil;
  end;
  { Log any errors. }
  if (ErrorCode <> 0) then
    DoLogMessage('TMatchingExport.LoadFromDB', ErrorCode, 'Error: ' + IntToStr(FuncRes));
end;

procedure TMatchingExport.SetOutputDirectory(const Value: string);
begin
  fOutputDirectory := Value;
  ForceDirectories(fOutputDirectory);
  if not DirectoryExists(fOutputDirectory) then
    DoLogMessage('TMatchingExport.SetOutputDirectory: ' +
                 'Directory does not exist and could not be created',
                 cNOOUTPUTDIRECTORY);
end;

function TMatchingExport.BuildRecord: Boolean;
var
  oMatching: IMatching2;
  FuncRes: Integer;
begin
  Result := False;
  oMatching := oToolkit.Transaction.thMatching as IMatching2;

//if (oTrans.thOurRef = 'SIN008427') then
//  oToolkit.Functions.entBrowseObject(oTrans, True);

  try
    FuncRes := oMatching.GetFirst;
    try
      while (FuncRes = 0) do
      begin
        if (oMatching.maType = maTypeFinancial) then
        begin
          { Add the record node. }
          XMLWriter.AddOpeningTag('matchrec');

          XMLWriter.AddLeafTag('madocyourref',  oMatching.maDocYourRef);
          XMLWriter.AddLeafTag('madocref',      oMatching.maDocRef);
          XMLWriter.AddLeafTag('mapayref',      oMatching.maPayRef);
          XMLWriter.AddLeafTag('matype',        oMatching.maType);
          XMLWriter.AddLeafTag('madoccurrency', oMatching.maDocCurrency);
          XMLWriter.AddLeafTag('madocvalue',    oMatching.maDocValue);
          XMLWriter.AddLeafTag('mapaycurrency', oMatching.maPayCurrency);
          XMLWriter.AddLeafTag('mapayvalue',    oMatching.maPayValue);
          XMLWriter.AddLeafTag('mabasevalue',   oMatching.maBaseValue);

          XMLWriter.AddClosingTag('matchrec');
        end;
        FuncRes := oMatching.GetNext;
      end;
      Result := True;
    except
      On e:Exception Do
        DoLogMessage('TMatchingExport.BuildRecord', cBUILDINGXMLERROR, 'Error: ' +
          e.message);
    end;
  finally
    oMatching := nil;
  end;
end;

end.
